# 测试文档 (Test Plan)
## 企业级分布式 ID 生成系统

**版本**: v1.1
**创建日期**: 2025-12-24  
**测试负责人**: QA 团队  
**状态**: ✅ 待执行

---

## 一、测试策略概述

### 1.1 测试目标
- 验证所有功能需求符合 PRD 规格
- 确保系统性能达到修正后的指标要求（**单实例 QPS > 1,000,000**, P99 < 10ms）
- 验证高可用和容错能力（含三级时钟回拨处理）
- 保证代码质量和可维护性

### 1.2 测试范围

| 测试类型 | 覆盖范围 | 执行阶段 | 状态 |
|---------|---------|---------|------|
| **单元测试** | 所有模块和函数 | 开发阶段 | 🟢 待执行 |
| **集成测试** | 模块间交互 | 开发完成后 | 🟢 待执行 |
| **性能测试** | QPS、延迟、并发 | 功能完成后 | 🟢 待执行 |
| **稳定性测试** | 长时间运行 | 上线前 | 🟢 待执行 |
| **容错测试** | 故障恢复 | 上线前 | 🟢 待执行 |
| **安全测试** | 权限、加密、API Key | 上线前 | 🟢 待执行 |

### 1.3 测试环境

| 环境 | 用途 | 配置 | 状态 |
|------|------|------|------|
| **开发环境** | 单元测试、调试 | 单节点 (Docker Compose) | 🟢 待搭建 |
| **测试环境** | 集成测试 | 3节点 + PostgreSQL + Redis + etcd | 🟢 待搭建 |
| **压测环境** | 性能测试 | 生产同等配置 (32核 CPU, 64G 内存) | 🟢 待搭建 |
| **预生产环境** | UAT验收 | 生产同等配置 | 🟢 待搭建 |

---

## 二、单元测试

### 2.1 算法引擎测试

#### 测试模块: Segment 号段算法

**测试用例 T-SEG-001: 基本 ID 生成**
- **描述**: 验证 Segment 算法能正常生成 ID
- **前置条件**: 数据库中已配置号段
- **测试步骤**:
  1. 调用 `segment.generate(ctx)`
  2. 验证返回 ID 为正整数
  3. 验证 ID 在分配的号段范围内
- **预期结果**: ID 生成成功且唯一
- **状态**: 🟢 待测试

**测试用例 T-SEG-002: 批量生成 ID**
- **描述**: 验证批量生成 1000 个 ID
- **测试步骤**:
  1. 调用 `segment.batch_generate(ctx, 1000)`
  2. 验证返回 1000 个 ID
  3. 验证所有 ID 唯一且递增
- **预期结果**: 批量生成成功
- **状态**: ⏳ 待测试

**测试用例 T-SEG-003: 号段耗尽切换 (DoubleBuffer)**
- **描述**: 验证当前号段耗尽后自动切换到预加载号段
- **测试步骤**:
  1. 消耗当前号段至剩余 10%
  2. 触发异步预加载
  3. 继续生成 ID 直至当前号段耗尽
  4. 验证无阻塞切换到 `next` 号段
- **预期结果**: 切换无感知，延迟 < 1μs
- **状态**: ⏳ 待测试

**测试用例 T-SEG-004: 动态步长调整**
- **描述**: 验证步长根据 QPS 自动调整
- **模拟场景**:
  - 低峰期 QPS = 1000 → 期望 step ≈ 1000
  - 高峰期 QPS = 50000 → 期望 step ≈ 10000
- **验证**: 查询数据库 segments 表的 step 字段
- **状态**: ⏳ 待测试

**测试用例 T-SEG-005: 数据库连接失败**
- **描述**: 验证数据库不可用时触发降级
- **测试步骤**:
  1. 停止 PostgreSQL 服务
  2. 调用 `segment.generate(ctx)`
  3. 验证返回错误并触发降级
- **预期结果**: 返回 `Error::DatabaseUnavailable`
- **状态**: ⏳ 待测试

#### 测试模块: Snowflake 算法 (修正版) ⏳ 待测试

**测试用例 T-SNOW-001: 基本 ID 生成**
- **描述**: 验证 Snowflake 算法生成的 ID 格式
- **验证点**:
  - ID 为 64 位整数
  - 时间戳部分正确（近似当前时间）
  - datacenter_id 和 worker_id 正确
- **状态**: ⏳ 待测试

**测试用例 T-SNOW-004: 微小时钟回拨 (< 5ms)**
- **描述**: 验证非阻塞等待队列处理微小回拨
- **测试步骤**:
  1. 模拟系统时钟回拨 3ms
  2. 并发请求 ID 生成
- **预期结果**: 
  - [ ] 线程不被阻塞 (Worker 线程保持活跃)
  - [ ] ID 在 3ms 后通过 `oneshot` 频道成功返回
  - [ ] 顺序性和唯一性保持

**测试用例 T-SNOW-005: 中等时钟回拨 (6-1000ms)**
- **描述**: 验证逻辑时钟处理中等回拨
- **测试步骤**:
  1. 模拟系统时钟回拨 100ms
  2. 请求 ID 生成
- **预期结果**: 
  - [ ] 立即返回 ID (无延迟)
  - [ ] ID 的时间戳部分使用 `logical_clock` (即 `last_timestamp + 1`)
  - [ ] 日志记录 `ClockDriftDetected` 警告

**测试用例 T-SNOW-006: 严重时钟回拨 (> 1000ms)**
- **描述**: 验证严重回拨时的降级逻辑
- **测试步骤**:
  1. 模拟系统时钟回拨 2s
  2. 请求 ID 生成
- **预期结果**: 
  - [ ] 自动切换至 `UUID v7` 算法
  - [ ] 响应中 `algorithm` 字段显示为 `uuid_v7`
  - [ ] 触发 `CriticalClockBackward` 告警

**测试用例 T-SNOW-003: 高并发序列号溢出**
- **描述**: 验证单毫秒内生成超过 1024 个 ID 的行为
- **测试步骤**:
  1. 在 1ms 内连续生成 1025 个 ID
  2. 验证第 1025 个 ID 等待下一毫秒
- **预期结果**: 自动等待，不返回重复 ID
- **状态**: ⏳ 待测试

#### 测试模块: UUID v7 算法 ⏳ 待测试

**测试用例 T-UUID-001: 基本生成**
- **描述**: 验证 UUID v7 格式
- **验证点**:
  - 符合 RFC 4122 标准
  - 包含时间戳（趋势递增）
  - 不依赖外部服务
- **状态**: ⏳ 待测试

**测试用例 T-UUID-002: 唯一性验证**
- **描述**: 并发生成 100万 个 UUID v7
- **验证**: 无重复
- **状态**: ⏳ 待测试

### 2.2 缓存层测试

#### 测试模块: RingBuffer (crossbeam::ArrayQueue)

**测试用例 T-RING-001: 环形缓冲区基本操作**
- **描述**: 验证 push/pop 操作 (支持通用 Id 类型)
- **测试步骤**:
  1. 创建容量为 1000 的 RingBuffer
  2. push 1000 个 ID (混合 Numeric 和 Uuid)
  3. pop 1000 个 ID
  4. 验证顺序正确且类型正确
- **状态**: 🟢 待测试

**测试用例 T-RING-002: 异步填充触发**
- **描述**: 验证剩余 10% 时触发异步填充
- **测试步骤**:
  1. RingBuffer 容量 1000，填充阈值 100
  2. pop 901 个 ID
  3. 验证异步填充被触发
- **预期结果**: 后台任务启动填充
- **状态**: ⏳ 待测试

**测试用例 T-RING-003: 并发读写安全**
- **描述**: 10 个线程并发 pop，1 个线程 push
- **验证**: 无数据竞争，无 ID 重复，无 Panic
- **状态**: ⏳ 待测试

#### 测试模块: DoubleBuffer (双缓冲号段) ⏳ 待测试

**测试用例 T-DBUF-001: 号段无缝切换**
- **描述**: 验证 DoubleBuffer 在号段耗尽时的切换逻辑
- **测试步骤**:
  1. 初始化 DoubleBuffer，Current=[0, 100], Next=[101, 200]
  2. 消费至 ID 100
  3. 再次消费
- **预期结果**:
  - [ ] 返回 ID 101
  - [ ] Current 变为 [101, 200]
  - [ ] Next 变为空并触发异步加载
- **状态**: ⏳ 待测试

**测试用例 T-DBUF-002: 预加载触发**
- **描述**: 验证剩余 10% 时触发预加载
- **测试步骤**:
  1. 消费 Current 号段至 90%
  2. 验证 `loader.preload_next_segment()` 被调用
- **状态**: ⏳ 待测试

### 2.3 降级策略测试

#### 测试模块: 算法降级链 ⏳ 待测试

**测试用例 T-DEG-001: 数据库故障降级**
- **描述**: PostgreSQL 不可用时切换至 Snowflake
- **故障模拟**: 停止 PostgreSQL 服务
- **验证**: 
  - ID 生成仍然成功
  - 使用 Snowflake 算法
  - 告警被触发
- **状态**: ⏳ 待测试

**测试用例 T-DEG-005: 完整降级链测试**
- **描述**: 验证 Segment → Snowflake → UUID v7 → UUID v4 降级链
- **测试步骤**:
  1. 正常情况：使用 Segment
  2. 停止 PostgreSQL：切换至 Snowflake
  3. 模拟严重时钟回拨 (>1000ms)：切换至 UUID v7
  4. 模拟 UUID v7 失败 (极端情况)：切换至 UUID v4
- **预期结果**: 
  - [ ] 每次降级无 ID 生成中断
  - [ ] 降级事件被记录
  - [ ] 告警被触发
  - [ ] 降级响应时间 < 1秒

**测试用例 T-DEG-006: 自动恢复测试**
- **描述**: 验证故障恢复后自动切回优先算法
- **测试步骤**:
  1. 触发 PostgreSQL 故障，降级至 Snowflake
  2. 持续生成 ID 1分钟
  3. 恢复 PostgreSQL
  4. 等待健康检查（30秒）
  5. 观察算法切换
- **预期结果**: 
  - [ ] 自动切回 Segment 算法
  - [ ] 切换过程无 ID 重复
  - [ ] 恢复事件被记录

---

## 三、集成测试

### 3.1 API 接口测试

#### 测试场景: HTTP API (含 API Key) ⏳ 待测试

**测试用例 T-API-001: 生成单个 ID**
```bash
curl -X POST http://localhost:8080/api/v1/generate \
  -H "Content-Type: application/json" \
  -H "X-API-Key: idgen_test_key_123" \
  -d '{
    "workspace": "test-ws",
    "group": "test-group",
    "biz_tag": "test-tag"
  }'
```
- **预期响应**: 200 OK, 返回 ID
- **状态**: ⏳ 待测试

**测试用例 T-API-002: 批量生成 ID**
```bash
curl -X POST http://localhost:8080/api/v1/generate/batch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: idgen_test_key_123" \
  -d '{
    "workspace": "test-ws",
    "group": "test-group",
    "biz_tag": "test-tag",
    "size": 100
  }'
```
- **预期响应**: 200 OK, 返回 100 个 ID
- **状态**: ⏳ 待测试

**测试用例 T-API-003: 解析 ID**
```bash
curl -X POST http://localhost:8080/api/v1/parse \
  -H "Content-Type: application/json" \
  -H "X-API-Key: idgen_test_key_123" \
  -d '{"id": "1234567890123456789"}'
```
- **预期响应**: 返回 ID 详细信息（时间戳、DC_ID等）
- **状态**: ⏳ 待测试

**测试用例 T-API-004: 健康检查**
```bash
curl http://localhost:8080/health
```
- **预期响应**: 200 OK, status: "healthy"
- **状态**: ⏳ 待测试

**测试用例 T-API-005: 错误处理 - 无效参数**
```bash
curl -X POST http://localhost:8080/api/v1/generate \
  -H "Content-Type: application/json" \
  -H "X-API-Key: idgen_test_key_123" \
  -d '{"workspace": ""}'
```
- **预期响应**: 400 Bad Request
- **状态**: ⏳ 待测试

**测试用例 T-SEC-005: API Key 验证**
- **描述**: 验证无效 API Key 被拒绝
- **测试步骤**:
  1. 使用错误的 `X-API-Key` 请求接口
  2. 验证返回 401 Unauthorized
  3. 不带 `X-API-Key` 请求接口
  4. 验证返回 401 Unauthorized
- **状态**: ⏳ 待测试

#### 测试场景: gRPC API ⏳ 待测试

**测试用例 T-GRPC-001: gRPC 生成 ID**
```bash
grpcurl -d '{
  "workspace": "test-ws",
  "group": "test-group",
  "biz_tag": "test-tag"
}' \
  -H "X-API-Key: idgen_test_key_123" \
  -plaintext localhost:9090 \
  idgen.v1.IdService/Generate
```
- **状态**: ⏳ 待测试

**测试用例 T-GRPC-002: gRPC 批量生成**
- **验证**: 批量生成 1000 个 ID
- **状态**: ⏳ 待测试

### 3.2 数据库集成测试

#### 测试场景: PostgreSQL 操作 ⏳ 待测试

**测试用例 T-DB-001: 号段分配乐观锁**
- **描述**: 验证并发分配号段时乐观锁生效
- **测试步骤**:
  1. 两个线程同时分配同一个号段
  2. 验证只有一个成功，另一个重试
- **状态**: ⏳ 待测试

**测试用例 T-DB-002: 连接池耗尽**
- **描述**: 模拟连接池满（200个连接）
- **测试步骤**:
  1. 占用 200 个连接
  2. 发起新请求
  3. 验证等待或超时错误
- **状态**: ⏳ 待测试

**测试用例 T-DB-003: 慢查询检测**
- **描述**: 验证慢查询被记录
- **测试步骤**:
  1. 执行一个耗时 > 1s 的查询
  2. 验证日志中有慢查询记录
- **状态**: ⏳ 待测试

### 3.3 跨数据中心测试

#### 测试场景: 多 DC 号段隔离与容灾 ⏳ 待测试

**测试用例 T-DC-001: DC 号段不冲突**
- **描述**: 验证不同 DC 生成的 ID 不重复
- **测试步骤**:
  1. DC1 生成 10万个 ID
  2. DC2 生成 10万个 ID
  3. 验证 20万个 ID 无重复 (检查 ID 区间是否按 TDD 4.2 配置隔离)
- **状态**: ⏳ 待测试

**测试用例 T-DC-005: Worker ID 自动分配 (etcd)**
- **描述**: 验证集群环境下每个节点获得唯一的 Worker ID
- **测试步骤**:
  1. 启动 10 个 ID 服务节点
  2. 验证每个节点的 `worker_id` 在 0-255 之间且不重复
  3. 停止其中一个节点，验证其 `worker_id` 在 30s 后被释放
  4. 启动新节点，验证其能复用释放的 `worker_id`
- **预期结果**: Worker ID 分配唯一且可自动回收
- **状态**: ⏳ 待测试

**测试用例 T-DC-006: DC 级别号段自动初始化**
- **描述**: 验证新业务标签在不同 DC 的号段自动初始化
- **测试步骤**:
  1. 创建一个新的 `biz_tag`
  2. 分别从 DC1 和 DC2 请求该标签的 ID
  3. 验证数据库中自动生成了两条对应的 `segments` 记录，且 `datacenter_id` 不同
- **预期结果**: 号段按 DC 物理隔离并自动初始化
- **状态**: ⏳ 待测试

**测试用例 T-DC-002: etcd 配置同步**
- **描述**: 验证配置变更在所有 DC 生效
- **测试步骤**:
  1. 在 DC1 修改配置
  2. 等待 5 秒
  3. 验证 DC2 配置已更新
- **状态**: ⏳ 待测试

**测试用例 T-DC-003: DC 级别故障切换 (容灾)**
- **描述**: 模拟整个数据中心故障时的自动切换
- **测试步骤**:
  1. 模拟 DC1 (北京) 整体不可用 (网络切断)
  2. 客户端请求自动通过全局 LB 转发至 DC2 (上海)
  3. 验证 DC2 能够接管请求并生成正确的 ID
- **预期结果**: 
  - [ ] 切换时间 < 10s (取决于 DNS/LB 探测)
  - [ ] 无 ID 重复
  - [ ] 监控面板显示流量切换

**测试用例 T-DC-004: 跨 DC 数据库同步延迟**
- **描述**: 模拟 PostgreSQL 跨 DC 异步复制延迟
- **测试步骤**:
  1. 模拟 DC1 与 DC2 数据库同步延迟 > 10s
  2. 在 DC1 更新号段
  3. 立即在 DC2 查询
- **预期结果**: 
  - [ ] 系统通过乐观锁 `version` 字段保证数据一致性
  - [ ] 避免出现脏读导致的 ID 重复

**测试用例 T-DC-007: etcd 网络分区测试 (脑裂场景)**
- **描述**: 验证 etcd 发生网络分区时 Worker ID 分配的安全性
- **测试步骤**:
  1. 将 etcd 集群划分为两个分区 (A, B)
  2. 在分区 A 中尝试启动新节点
  3. 在分区 B 中尝试启动新节点
- **预期结果**: 
  - [ ] 只有多数派分区 (Quorum) 能成功分配 Worker ID
  - [ ] 少数派分区节点启动失败并记录明确错误
- **状态**: ⏳ 待测试

**测试用例 T-DC-008: 全局数据一致性巡检**
- **描述**: 验证多 DC 环境下所有 segments 的隔离性
- **测试步骤**:
  1. 运行全局巡检脚本，扫描所有 DC 的 `segments` 表
  2. 验证任意两个 `(name_id, datacenter_id)` 不同的记录其 ID 区间 `[start_id, max_id]` 均不重叠
- **预期结果**: 
  - [ ] 所有区间物理隔离
  - [ ] 无重叠风险
- **状态**: ⏳ 待测试

---

## 四、性能测试

### 4.1 压力测试

#### 测试场景: 单实例性能 (百万级 QPS) ⏳ 待测试

**测试用例 T-PERF-001: 单实例百万级 QPS 压测**
- **工具**: wrk + 自定义 Lua 脚本
- **配置**: 
  - 并发数: 10,000
  - 线程数: 32
  - 持续时间: 10 分钟
  - 目标 QPS: 1,000,000+
- **验收指标**:
  - [ ] QPS > 1,000,000
  - [ ] P50 延迟 < 1ms
  - [ ] P99 延迟 < 10ms
  - [ ] P999 延迟 < 50ms
  - [ ] 错误率 < 0.001%
  - [ ] CPU 使用率 < 85%
  - [ ] 内存占用 < 4GB
- **状态**: ⏳ 待测试

**测试脚本 (generate.lua)**:
```lua
wrk.method = "POST"
wrk.headers["Content-Type"] = "application/json"
wrk.headers["X-API-Key"] = "idgen_perf_key"
wrk.body = '{"workspace":"test","group":"perf","biz_tag":"test-id"}'
```

**执行命令**:
```bash
wrk -t 32 -c 10000 -d 600s \
  --latency \
  -s generate.lua \
  http://localhost:8080/api/v1/generate
```

**测试用例 T-PERF-002: 批量生成性能**
- **场景**: 批量生成 1000 个 ID
- **验证**: 
  - 总耗时 < 100ms
  - 平均单个 ID 生成 < 0.1ms
- **状态**: ⏳ 待测试

**测试用例 T-PERF-003: 内存占用**
- **测试步骤**:
  1. 启动服务
  2. 运行压测 1 小时
  3. 监控内存占用
- **验证**: 
  - 初始内存 < 500MB
  - 稳定后内存 < 4GB
  - 无内存泄漏
- **状态**: ⏳ 待测试

#### 测试场景: 集群性能 ⏳ 待测试

**测试用例 T-PERF-004: 3节点集群 QPS**
- **配置**: 3 个节点，负载均衡
- **目标**: 总 QPS > 10,000,000 (千万级)
- **状态**: ⏳ 待测试

**测试用例 T-PERF-005: 水平扩容**
- **测试步骤**:
  1. 3 节点集群压测，记录 QPS_3
  2. 增加到 6 个节点
  3. 再次压测，记录 QPS_6
  4. 验证 QPS_6 ≈ 2 × QPS_3
- **状态**: ⏳ 待测试

### 4.2 稳定性测试

#### 测试场景: 长时间运行 ⏳ 待测试

**测试用例 T-STAB-001: 7天稳定性测试**
- **配置**: 
  - QPS: 50,000（中等负载）
  - 持续时间: 7 天
- **监控指标**:
  - CPU 使用率稳定在 < 70%
  - 内存无泄漏
  - 无异常重启
  - 错误率 < 0.001%
- **状态**: ⏳ 待测试

**测试用例 T-STAB-002: 高负载稳定性**
- **配置**: 
  - QPS: 500,000（高负载）
  - 持续时间: 24 小时
- **验证**: 
  - P99 延迟始终 < 10ms
  - 无 OOM
- **状态**: ⏳ 待测试

### 4.3 边界条件测试

#### 测试场景: 极限场景 ⏳ 待测试

**测试用例 T-EDGE-001: 号段即将耗尽**
- **描述**: 模拟号段只剩 1% 时的行为
- **验证**: 
  - 自动分配新号段
  - 无 ID 生成中断
- **状态**: ⏳ 待测试

**测试用例 T-EDGE-002: 批量大小边界**
- **场景**: 批量生成 10,000 个 ID（超大批量）
- **验证**: 
  - 成功返回或合理拒绝
  - 不导致服务崩溃
- **状态**: ⏳ 待测试

**测试用例 T-EDGE-003: 极高并发**
- **场景**: 20,000 并发请求
- **验证**: 
  - 所有请求最终成功或超时
  - 无死锁
- **状态**: ⏳ 待测试

---

## 五、容错测试

### 5.1 组件故障测试

#### 测试场景: PostgreSQL 故障 ⏳ 待测试

**测试用例 T-FAULT-001: 主库故障切换**
- **故障模拟**: Kill PostgreSQL 主库进程
- **验证**:
  - Patroni 自动选举新主库（< 30s）
  - ID 生成在切换期间降级至 Snowflake
  - 切换完成后恢复 Segment 算法
- **状态**: ⏳ 待测试

**测试用例 T-FAULT-002: 数据库连接中断**
- **故障模拟**: 断开数据库网络连接
- **验证**: 
  - 降级至 Snowflake
  - 连接恢复后自动切回
- **状态**: ⏳ 待测试

#### 测试场景: Redis 故障 ⏳ 待测试

**测试用例 T-FAULT-003: Redis 集群节点故障**
- **故障模拟**: Kill 1 个 Redis 节点
- **验证**: 
  - 缓存命中率降低但服务正常
  - 自动重连到健康节点
- **状态**: ⏳ 待测试

**测试用例 T-FAULT-004: Redis 完全不可用**
- **故障模拟**: 停止所有 Redis 节点
- **验证**: 
  - 直接访问数据库
  - 性能下降但仍可用
- **状态**: ⏳ 待测试

#### 测试场景: etcd 故障 ⏳ 待测试

**测试用例 T-FAULT-005: etcd 集群失联**
- **故障模拟**: 网络分区导致 etcd 不可达
- **验证**: 
  - 使用本地缓存配置继续运行
  - 配置无法更新但服务不中断
- **状态**: ⏳ 待测试

### 5.2 网络故障测试

#### 测试场景: 网络延迟

**测试用例 T-NET-001: 数据库延迟增加**
- **故障模拟**: 使用 tc 添加 100ms 网络延迟
- **验证**: 
  - P99 延迟增加但 < 200ms
  - 触发号段预加载
- **状态**: 🟢 待测试

**测试用例 T-NET-002: 跨 DC 网络抖动**
- **故障模拟**: DC 间网络延迟波动 10-200ms
- **验证**: 
  - 本地 DC 优先
  - 远程配置更新可能延迟但最终一致
- **状态**: ⏳ 待测试

---

## 六、安全测试

### 6.1 认证授权测试 ⏳ 待测试

**测试用例 T-SEC-001: TLS 加密**
- **描述**: 验证所有外部接口强制 HTTPS
- **测试步骤**:
  1. 尝试 HTTP 请求
  2. 验证被重定向到 HTTPS 或拒绝
- **状态**: ⏳ 待测试

**测试用例 T-SEC-002: API 限流**
- **描述**: 验证单 IP 限流 1000 QPS
- **测试步骤**:
  1. 单 IP 发送 1500 QPS
  2. 验证超过部分被拒绝（429 Too Many Requests）
- **状态**: ⏳ 待测试

### 6.2 数据安全测试 ⏳ 待测试

**测试用例 T-SEC-003: 数据库连接加密**
- **描述**: 验证 PostgreSQL 连接使用 TLS
- **验证**: 抓包查看流量加密
- **状态**: ⏳ 待测试

**测试用例 T-SEC-004: 审计日志完整性**
- **描述**: 验证所有配置变更被记录
- **测试步骤**:
  1. 修改业务单元配置
  2. 查询审计日志
  3. 验证记录完整（时间、用户、操作、结果）
- **状态**: ⏳ 待测试

---

## 七、测试数据准备

### 7.1 基础测试数据 ⏳ 待准备

```sql
-- 工作空间
INSERT INTO workspaces (id, name) VALUES 
  ('ws-test', 'Test Workspace'),
  ('ws-prod', 'Production Workspace');

-- API Key
INSERT INTO api_keys (workspace_id, key_hash, key_prefix) VALUES
  ('ws-test', 'hash_of_idgen_test_key_123', 'idgen_test');

-- 分组
INSERT INTO groups (id, workspace_id, name) VALUES 
  ('grp-order', 'ws-test', 'Order System'),
  ('grp-user', 'ws-test', 'User System');

-- 业务标签 (biz_tags)
INSERT INTO biz_tags (id, group_id, name, algorithm, id_format, config) VALUES 
  ('tag-order-id', 'grp-order', 'order-id', 'segment', 'numeric', 
   '{"base_step": 10000}'::jsonb),
  ('tag-user-id', 'grp-user', 'user-id', 'snowflake', 'numeric',
   '{}'::jsonb);

-- 号段初始化 (DC 0)
INSERT INTO segments (biz_tag_id, datacenter_id, current_id, max_id, step, base_step) VALUES 
  ('tag-order-id', 0, 1000000000000, 1999999999999, 10000, 10000);
```

### 7.2 压测数据 ⏳ 待准备

- **并发用户**: 10,000 个虚拟用户
- **请求模板**: 20 个不同的 workspace/group/biz_tag 组合
- **负载曲线**: 梯形负载（0 → 1M QPS → 1M → 0）

---

## 八、测试指标汇总

### 8.1 功能测试通过标准

| 模块 | 总用例数 | 通过标准 | 状态 |
|------|---------|---------|------|
| 算法引擎 | 15 | 100% 通过 | ⏳ 待测试 |
| 缓存层 | 5 | 100% 通过 | ⏳ 待测试 |
| 降级策略 | 4 | 100% 通过 | ⏳ 待测试 |
| API 接口 | 11 | 100% 通过 | ⏳ 待测试 |
| 数据库集成 | 3 | 100% 通过 | ⏳ 待测试 |
| 跨 DC | 3 | 100% 通过 | ⏳ 待测试 |

### 8.2 性能测试通过标准

| 指标 | 目标值 | 实际值 | 状态 |
|------|--------|--------|------|
| **单实例 QPS** | **> 1,000,000** | - | ⏳ 待测试 |
| **P50 延迟** | < 1ms | - | ⏳ 待测试 |
| **P99 延迟** | < 10ms | - | ⏳ 待测试 |
| **内存占用** | < 4GB | - | ⏳ 待测试 |
| **7天稳定性** | 错误率 < 0.001% | - | ⏳ 待测试 |

### 8.3 容错测试通过标准

| 场景 | 目标 | 状态 |
|------|------|------|
| **数据库故障** | RTO < 30s，自动降级 | ⏳ 待测试 |
| **Redis 故障** | 服务不中断 | ⏳ 待测试 |
| **etcd 故障** | 使用缓存配置运行 | ⏳ 待测试 |
| **网络延迟** | P99 < 200ms | ⏳ 待测试 |
| **时钟回拨** | <1s 无感，>1s 降级 | ⏳ 待测试 |

---

## 九、测试工具清单

| 工具 | 用途 | 状态 |
|------|------|------|
| **cargo test** | 单元测试 | 🟢 已配置 |
| **wrk / k6** | HTTP 压力测试 (需支持 Lua) | 🟢 已安装 |
| **ghz** | gRPC 压力测试 | 🟢 已安装 |
| **Prometheus** | 性能监控 | 🟢 已部署 |
| **Grafana** | 可视化 | ⏳ 待部署 |
| **tc (Traffic Control)** | 网络故障模拟 | ⏳ 待配置 |
| **Chaos Mesh** | Kubernetes 故障注入 | ⏳ 待部署 |

---

## 十、测试里程碑

| 阶段 | 时间 | 交付物 | 状态 |
|------|------|--------|------|
| **Phase 1** | Week 1-4 | 单元测试完成，覆盖率 > 80% | ⏳ 待开始 |
| **Phase 2** | Week 5-8 | 集成测试完成 | ⏳ 待开始 |
| **Phase 3** | Week 9-11 | 百万级性能测试 + 容错测试完成 | ⏳ 待开始 |
| **Phase 4** | Week 12-14 | 安全测试 + 稳定性测试完成 | ⏳ 待开始 |

---

**文档状态**: ⏳ 待执行  
**下次更新日期**: 待定  
**测试负责人**: QA Team